import { defineComponent } from 'vue';
import { hasFlag, defaultIfUndefined } from './helpers.mjs';

const items = 1;
const sorted = 3;
const Sorted = sorted;
var ProviderParentMixin = (itemName, flags = 0) => {
    const mixin = defineComponent({
        provide() {
            return {
                ['o' + itemName]: this
            };
        }
    });
    if (hasFlag(flags, items)) {
        mixin.data = function () {
            return {
                childItems: [],
                sequence: 1
            };
        };
        mixin.methods = {
            _registerItem(item) {
                item.index = this.childItems.length;
                this.childItems.push(item);
                if (this.$el) {
                    this.$nextTick(() => {
                        const ids = this.childItems.map(it => `[data-id="${itemName}-${it.newValue}"]`).join(',');
                        const sortedIds = Array.from(this.$el.querySelectorAll(ids)).map((el) => el.getAttribute('data-id').replace(`${itemName}-`, ''));
                        this.childItems.forEach(it => it.index = sortedIds.indexOf(`${it.newValue}`));
                    });
                }
            },
            _unregisterItem(item) {
                this.childItems = this.childItems.filter((i) => i !== item);
            },
            _nextSequence() {
                return this.sequence++;
            }
        };
        if (hasFlag(flags, sorted)) {
            mixin.computed = {
                /**
                 * When items are added/removed sort them according to their position
                 */
                sortedItems() {
                    return this.childItems.slice().sort((i1, i2) => {
                        return i1.index - i2.index;
                    });
                }
            };
        }
    }
    return mixin;
};

const sorted$1 = 1;
const optional = 2;
const Sorted$1 = sorted$1;
var InjectedChildMixin = (parentItemName, flags = 0) => {
    const mixin = defineComponent({
        inject: {
            parent: { from: 'o' + parentItemName }
        },
        created() {
            this.newValue = defaultIfUndefined(this.value, this.parent._nextSequence());
            if (!this.parent) {
                if (!hasFlag(flags, optional)) {
                    throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName);
                }
            }
            else {
                this.parent._registerItem(this);
            }
        },
        beforeUnmount() {
            if (this.parent) {
                this.parent._unregisterItem(this);
            }
        }
    });
    if (hasFlag(flags, sorted$1)) {
        mixin.data = () => {
            return {
                index: null
            };
        };
    }
    return mixin;
};

export { InjectedChildMixin as I, ProviderParentMixin as P, Sorted as S, Sorted$1 as a };
